# Docker 学习

### 任务目标：

1. 引言
2. 理解Docker与虚拟机的区别，理解核心概念
3. 掌握常用核心命令
4. 学习编写dockerfile
5. 端口映射
   - 理解容器内部⽹络与宿主机的关系
   - 掌握 -p 端⼝映射参数，将容器服务暴露给外部
6. 学习使用DockerHub
7. 感悟
8. 鸣谢

### 一、引言

经过上一周的Linux、vim、git的学习，笔者对于Linux系统有了一个基本的认识，这一周，笔者先来学习docker的使用。那么docker到底指的是什么呢，笔者先去问了 [百度翻译](https://fanyi.baidu.com/mtpe-individual/transText#/) ：

> Docker 的翻译可以根据不同语境灵活处理，通常译为"码头工人"。

emmmm……看来这应该不是笔者要学习的东西……

### 二、理解Docker与虚拟机的区别，理解核心概念。

关于Docker到底除了码头工人之外还指什么，[百度百科](https://baike.baidu.com/item/Docker/13344470?fr=aladdin) 给出了如下回答：

> Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。

这样看来，似乎我们的Docker和虚拟机很像，但是他们是有区别的：

| 特性                   | Docker                                                       | 虚拟机                                                       |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **虚拟化层级**         | 操作系统级虚拟，相当于创建一个单独的容器空间                 | 硬件级虚拟，通过一些软件比如VMware模拟一个完整的硬件环境     |
| **资源占用与响应时间** | 资源占用较少，响应时间快，毫秒级别响应                       | 资源占用较大，响应时间慢，甚至可能数十秒                     |
| **性能**               | 较好，因为直接在原系统中操作                                 | 较差，因为与原系统之间存在一个介质                           |
| **隔离性与安全性**     | 较差，一个容器被攻破之后可能会导致其它容器损坏               | 较好，由于各个虚拟机较为独立，所以不易相互影响               |
| **可移植性**           | 借助Docker的镜像功能可以较为轻松地移植                       | 对各种部件依赖性较强，所以不易移植                           |
| **应用场景**           | 适合微服务架构、持续集成/持续部署（CI/CD）、开发测试环境隔离等场景 | 适合需要完全隔离的应用，如多租户环境、遗留应用迁移、不同操作系统共存等场景 |

~~（怎么看起来Docker各方面完爆虚拟机呢）~~

##### Docker核心概念

虽然说前文详细比较了Docker与虚拟机的区别，但是不能认为Docker就是用来充当虚拟机的。而说到这，就不得不说Docker的三大核心概念了：**镜像、容器、仓库** 。

**镜像** ，指的是一种只读的模板，里面放什么都可以，比如如果把编程前要进行的配置放进去，下次来使用的时候就可以不用配置了，直接用这个镜像就可以完成。

**容器** ，指的是对镜像进行操作之后的产物，与镜像不同的是，镜像是只读的，不可更改，但是按照镜像产生出来的容器可以任意处置。

**仓库** ，用来存放镜像的地方。

做一个通俗的比喻的话，镜像就像我们买来的或者自己做好的蛋糕模具，在没有蛋糕的时候它就仅仅是模具，但是一旦要用它来做蛋糕（容器），那么就会做出许多一模一样的蛋糕。当然，蛋糕做好之后如果想要立即吃掉，加点糖霜还是直接扔进垃圾桶都是随意的。而仓库就是我们的厨房里存储蛋糕模具的地方。

##### 分层镜像

分层镜像的存在也说明了为什么Docker的处理速度可以比虚拟机快这么多。

现在想象笔者要开发二十个软件，如果笔者使用虚拟机的话，结果是笔者需要二十个虚拟机！但是，由于Docker的分层镜像功能，我们现在可以为所有的软件创建一些共有的内容镜像，这样可以节省大量的空间，检索起来也一点都不费劲了，只需要找到作为共有镜像的根，下面再按照软件其他内容去找很容易就可以找到目标镜像。

### 掌握常用核心命令

现在大致了解了Docker的用途与基本核心概念，现在应该接触一下基础命令了。

既然要开始写代码，那么少不了的肯定要先安装Docker。当然了，安装也不是什么难事，在伟大的 [鱼香ROS](http://fishros.com/) 的帮助下，Docker顺利地安装完成了。

下面就是正式来学习各种命令了：

``` shell
# 查看本地镜像
docker images

# 从仓库拉取镜像
docker pull nginx:latest
docker pull ubuntu:20.04

# 删除镜像
docker rmi image_id
docker rmi nginx:latest

# 构建镜像
docker build -t my-app:1.0 .
```

这些命令允许我们对我们的镜像和仓库进行操作，算是各种操作的基石了。

##### 遇到的问题

那么就有帅哥美女这时候要问了，啊你怎么用一段代码放在这啊，你的实机操作截图被你吃了？那么这时候就不得不说了，笔者的Linux可以安装Docker，但是用不了。笔者求助网络与学长之后得到一个结论，那就是要想在国内用要一些magic，然鹅笔者法术太浅，只能暂时将学习停留在理论层面了……不过呢，Docker的学习路径中有一些是用不到网络的，比如自己创建Dockerfile等，到那时就可以进行实机操作了。

``` shell
# 运行容器
docker run -d --name my-nginx nginx                    # 后台运行
docker run -it ubuntu:22.04 /bin/bash                 # 交互式运行

# 查看容器
docker ps                    # 查看运行中的容器
docker ps -a                 # 查看所有容器

# 停止/启动/删除容器
docker stop container_id     # 停止容器
docker start container_id    # 启动已停止的容器
docker rm container_id       # 删除容器
docker rm -f container_id    # 强制删除运行中的容器
```

上面这些代码是有关容器的操作，包括运行、删除等操作。

### 四、学习Dockerfile

这一部分是真正的开始，从此正式踏入了Docker的编写。

Dockerfile是用于构建镜像的文件，通过编写Dockerfile可以创建镜像。

| 指令           | 主要功能                                                     | 示例                                           |
| :------------- | :----------------------------------------------------------- | :--------------------------------------------- |
| **FROM**       | 指定基础镜像，必须是第一条指令。                             | `FROM ubuntu:20.04`                            |
| **RUN**        | 在构建过程中执行命令，常用于安装软件、配置环境。             | `RUN apt-get update && apt-get install -y vim` |
| **COPY**       | 将宿主机文件或目录复制到镜像内。                             | `COPY ./app /app`                              |
| **ADD**        | 类似 COPY，但支持 URL 源和自动解压压缩包。                   | `ADD https://example.com/file.tar.gz /opt/`    |
| **WORKDIR**    | 设置后续指令的工作目录，若目录不存在则自动创建。             | `WORKDIR /app`                                 |
| **ENV**        | 设置环境变量，在构建和容器运行时均有效。                     | `ENV NODE_ENV production`                      |
| **EXPOSE**     | 声明容器运行时监听的端口，但这只是声明，实际映射需要在 `docker run` 时使用 `-p` 参数指定。 | `EXPOSE 80`                                    |
| **CMD**        | 指定容器**启动时**默认执行的命令，可以被 `docker run` 后面的命令行参数覆盖。 | `CMD ["python", "app.py"]`                     |
| **ENTRYPOINT** | 配置容器启动后执行的命令，不易被 `docker run` 提供的参数覆盖。 | `ENTRYPOINT ["top", "-b"]`                     |

出于上文提到过的原因，此处笔者仍旧不能在自己的Linux中成功地使用Docker，于是只好做到哪步算哪步了:(

![笔者将该图片上传至GitHub，如果不能正常显示，有可能是因为笔者操作失误。图片内容为操作过程截图。](https://github.com/88fkb88/Photos/blob/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-10-20%20014200.png?raw=true)

### 五、端口映射

在Docker中，每个容器并不是可以被随意访问的，是有自己的独立网络空间的。在默认情况下，容器端口在宿主机外是不可访问的，这时候就需要我们的端口映射上场了。

``` shell
# 基本格式：-p 宿主机端口:容器端口
docker run -p 8080:80 nginx          # 访问宿主机的8080端口会转发到容器的80端口
docker run -p 80:80 nginx            # 宿主80 → 容器80
docker run -p 3000:3000 my-app       # 宿主3000 → 容器3000

# 映射多个端口
docker run -p 8080:80 -p 8443:443 nginx

# 让Docker自动选择宿主机端口
docker run -p 80 nginx               # 查看实际映射的端口用 docker ps
```

其中，指令中两个数字指的是外部访问与内部访问相对接的端口，-p 代指宿主机。

### 六、DockerHub

依照笔者理解，这个DockerHub应该和GitHub情况类似，只是一个用Git访问一个用Docker访问

同样地，DockerHub也拥有拉取、推送等功能：

``` shell
# 搜索镜像
docker search nginx
docker search python

# 拉取镜像（不指定tag默认拉取latest）
docker pull nginx
docker pull nginx:1.21
docker pull python:3.9-slim

# 推送镜像到 Docker Hub
# 1. 登录 Docker Hub
docker login

# 2. 标记镜像（格式：dockerhub用户名/镜像名:标签）
docker tag my-app:1.0 yourusername/my-app:1.0

# 3. 推送镜像
docker push yourusername/my-app:1.0

# 4. 其他人就可以拉取你的镜像了
docker pull yourusername/my-app:1.0
```

### 七、感悟

客观来说，这次Docker的学习过程并不顺利，并且到最后也没能解决Docker的使用问题。但是遗憾的是，笔者暂时没有办法整到更厉害的magic，所以只能暂且放一放了。

不过，即使没能实机操作，笔者依旧接触到了Docker的各种使用。在最开始的时候，笔者不是很清楚什么镜像啥的都是干啥用的，因为笔者并没有对于“开发环境”这一个词有什么深刻的理解。不过经过学习之后，笔者了解到在很多时候仅仅写代码是不够用的，还需要有一个配套的环境，这也是我们使用Docker的一大目的。

### 八、鸣谢

~~(tips:笔者其实并不知道应不应该有这部分，但是笔者决定加上)~~

在此次学习过程中笔者主要要感谢群中学长拓展了笔者的视野。

其次要感谢deepseek以及网上各路大神的帖子帮助了我的学习。

# THE END





